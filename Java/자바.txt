자바 애플리케이션 실행 과정
- 컴파일러가 자바소스를 바이트코드로 변환하고 Class Loader가 바이트 코드를 런타임 데이터 영역에 로드시킴. 로딩된 바이트 코드가 실행엔진에 의해 실행됨.
JVM은 Java 클래스 파일을 로드하고 바이트 코드를 해석하며 메모리 등의 자원을 할당하고 관리하며 정보를 처리하는 작업을 하는 프로그램

자바 메모리 구조
- 스레드별
PC Register : 현재 수행중인 JVM 명령어
JVM Stack : 호출된 메소드의 매개변수, 지역변수, 리턴정보 등이 저장
Native Method Stack : 자바 외 다른 언어로 작성된 코드
- 공통
Method Area : 각 클래스별 전역변수, 정적변수, 메소드 정보가 저장
Heap : 런 타임중 생성되는 객체들이 동적으로 할당

가비지 컬렉션(GC)
- JVM에서 메모리 관리해주는 모듈로 Heap 메모리를 재활용하기 위해서 더이상 참조되지 않는 객체들을 메모리에서 제거하는 모듈.
개발자가 더이상 직접 메모리를 정리하지 않아도 되어서 개발속도가 향상되는 장점이 있지만, Mark and Sweep 과정에서 스레드가 잠시 중단되어서 성능이 떨어지는 단점이 존재함.

객체지향 프로그래밍
- 현실세계의 사물같은 객체를 만들고 객체에서 필요한 특징을 뽑아 프로그래밍 수행.
4가지 특징
- 추상화 : 객체의 본질적인 특징만 추출하여 모델링 하는 과정.
- 캡슐화 : 정보은닉을 통해 내부적으로는 높은 응집도를 가지고 외부에서는 낮은 결합도를 가질 수 있도록 설계. 외부에서 접근하지 못하도록 보호.
- 상속성 : 부모 클래스의 속성과 기능을 자식클래스에서 재사용할 수 있도록 하는 것.
- 다형성 : 같은 인터페이스나 부모클래스를 공유하는 객체가 서로 다른 방식으로 동작할 수 있도록 하는 것.

오버로딩 vs 오버라이딩
- 오버로딩 : 같은 이름의 메소드를 매개변수 형태에 따라 다르게 정의.
- 오버라이딩 : 부모 클래스의 메소드를 자식 클래스에서 재정의. 메소드 이름, 매개변수, 리턴타입 모두 동일해야 함.

추상클래스 vs 인터페이스
- 추상클래스 : abstract로 지시자로 정의되며 추상메소드가 하나이상 포함. 부모클래스를 상속을 하기 위해 사용.
- 인터페이스 : interface 지시자로 정의되며 모든 메소드가 추상메소드로 정의. 부모 인터페이스의 기능을 사용한다는 것을 보장하기 위해 사용.
차이점 : 존재의 목적
추상클래스는 상속받아서 기능을 재활용하고 확장시키는 것에 목적.
인터페이스는 함수의 구현을 강제해서 구현한 객체들이 같은 동작을 하는 것을 보장하는 것에 목적.